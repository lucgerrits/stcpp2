// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transaction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transaction_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transaction_2eproto;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionHeader;
class TransactionHeaderDefaultTypeInternal;
extern TransactionHeaderDefaultTypeInternal _TransactionHeader_default_instance_;
class TransactionList;
class TransactionListDefaultTypeInternal;
extern TransactionListDefaultTypeInternal _TransactionList_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Transaction* Arena::CreateMaybeMessage<::Transaction>(Arena*);
template<> ::TransactionHeader* Arena::CreateMaybeMessage<::TransactionHeader>(Arena*);
template<> ::TransactionList* Arena::CreateMaybeMessage<::TransactionList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class TransactionHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransactionHeader) */ {
 public:
  TransactionHeader();
  virtual ~TransactionHeader();

  TransactionHeader(const TransactionHeader& from);
  TransactionHeader(TransactionHeader&& from) noexcept
    : TransactionHeader() {
    *this = ::std::move(from);
  }

  inline TransactionHeader& operator=(const TransactionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionHeader& operator=(TransactionHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransactionHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionHeader* internal_default_instance() {
    return reinterpret_cast<const TransactionHeader*>(
               &_TransactionHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TransactionHeader* other);
  friend void swap(TransactionHeader& a, TransactionHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionHeader* New() const final {
    return CreateMaybeMessage<TransactionHeader>(nullptr);
  }

  TransactionHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransactionHeader& from);
  void MergeFrom(const TransactionHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransactionHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transaction_2eproto);
    return ::descriptor_table_transaction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string dependencies = 2;
  int dependencies_size() const;
  void clear_dependencies();
  static const int kDependenciesFieldNumber = 2;
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  void set_dependencies(int index, const std::string& value);
  void set_dependencies(int index, std::string&& value);
  void set_dependencies(int index, const char* value);
  void set_dependencies(int index, const char* value, size_t size);
  std::string* add_dependencies();
  void add_dependencies(const std::string& value);
  void add_dependencies(std::string&& value);
  void add_dependencies(const char* value);
  void add_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dependencies();

  // repeated string inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const std::string& inputs(int index) const;
  std::string* mutable_inputs(int index);
  void set_inputs(int index, const std::string& value);
  void set_inputs(int index, std::string&& value);
  void set_inputs(int index, const char* value);
  void set_inputs(int index, const char* value, size_t size);
  std::string* add_inputs();
  void add_inputs(const std::string& value);
  void add_inputs(std::string&& value);
  void add_inputs(const char* value);
  void add_inputs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& inputs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_inputs();

  // repeated string outputs = 7;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 7;
  const std::string& outputs(int index) const;
  std::string* mutable_outputs(int index);
  void set_outputs(int index, const std::string& value);
  void set_outputs(int index, std::string&& value);
  void set_outputs(int index, const char* value);
  void set_outputs(int index, const char* value, size_t size);
  std::string* add_outputs();
  void add_outputs(const std::string& value);
  void add_outputs(std::string&& value);
  void add_outputs(const char* value);
  void add_outputs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& outputs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_outputs();

  // string batcher_public_key = 1;
  void clear_batcher_public_key();
  static const int kBatcherPublicKeyFieldNumber = 1;
  const std::string& batcher_public_key() const;
  void set_batcher_public_key(const std::string& value);
  void set_batcher_public_key(std::string&& value);
  void set_batcher_public_key(const char* value);
  void set_batcher_public_key(const char* value, size_t size);
  std::string* mutable_batcher_public_key();
  std::string* release_batcher_public_key();
  void set_allocated_batcher_public_key(std::string* batcher_public_key);

  // string family_name = 3;
  void clear_family_name();
  static const int kFamilyNameFieldNumber = 3;
  const std::string& family_name() const;
  void set_family_name(const std::string& value);
  void set_family_name(std::string&& value);
  void set_family_name(const char* value);
  void set_family_name(const char* value, size_t size);
  std::string* mutable_family_name();
  std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);

  // string family_version = 4;
  void clear_family_version();
  static const int kFamilyVersionFieldNumber = 4;
  const std::string& family_version() const;
  void set_family_version(const std::string& value);
  void set_family_version(std::string&& value);
  void set_family_version(const char* value);
  void set_family_version(const char* value, size_t size);
  std::string* mutable_family_version();
  std::string* release_family_version();
  void set_allocated_family_version(std::string* family_version);

  // string nonce = 6;
  void clear_nonce();
  static const int kNonceFieldNumber = 6;
  const std::string& nonce() const;
  void set_nonce(const std::string& value);
  void set_nonce(std::string&& value);
  void set_nonce(const char* value);
  void set_nonce(const char* value, size_t size);
  std::string* mutable_nonce();
  std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);

  // string payload_sha512 = 9;
  void clear_payload_sha512();
  static const int kPayloadSha512FieldNumber = 9;
  const std::string& payload_sha512() const;
  void set_payload_sha512(const std::string& value);
  void set_payload_sha512(std::string&& value);
  void set_payload_sha512(const char* value);
  void set_payload_sha512(const char* value, size_t size);
  std::string* mutable_payload_sha512();
  std::string* release_payload_sha512();
  void set_allocated_payload_sha512(std::string* payload_sha512);

  // string signer_public_key = 10;
  void clear_signer_public_key();
  static const int kSignerPublicKeyFieldNumber = 10;
  const std::string& signer_public_key() const;
  void set_signer_public_key(const std::string& value);
  void set_signer_public_key(std::string&& value);
  void set_signer_public_key(const char* value);
  void set_signer_public_key(const char* value, size_t size);
  std::string* mutable_signer_public_key();
  std::string* release_signer_public_key();
  void set_allocated_signer_public_key(std::string* signer_public_key);

  // @@protoc_insertion_point(class_scope:TransactionHeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dependencies_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> outputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr batcher_public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_sha512_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class Transaction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Transaction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transaction_2eproto);
    return ::descriptor_table_transaction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes header = 1;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const std::string& header() const;
  void set_header(const std::string& value);
  void set_header(std::string&& value);
  void set_header(const char* value);
  void set_header(const void* value, size_t size);
  std::string* mutable_header();
  std::string* release_header();
  void set_allocated_header(std::string* header);

  // string header_signature = 2;
  void clear_header_signature();
  static const int kHeaderSignatureFieldNumber = 2;
  const std::string& header_signature() const;
  void set_header_signature(const std::string& value);
  void set_header_signature(std::string&& value);
  void set_header_signature(const char* value);
  void set_header_signature(const char* value, size_t size);
  std::string* mutable_header_signature();
  std::string* release_header_signature();
  void set_allocated_header_signature(std::string* header_signature);

  // bytes payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);

  // @@protoc_insertion_point(class_scope:Transaction)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransactionList) */ {
 public:
  TransactionList();
  virtual ~TransactionList();

  TransactionList(const TransactionList& from);
  TransactionList(TransactionList&& from) noexcept
    : TransactionList() {
    *this = ::std::move(from);
  }

  inline TransactionList& operator=(const TransactionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionList& operator=(TransactionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransactionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionList* internal_default_instance() {
    return reinterpret_cast<const TransactionList*>(
               &_TransactionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TransactionList* other);
  friend void swap(TransactionList& a, TransactionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionList* New() const final {
    return CreateMaybeMessage<TransactionList>(nullptr);
  }

  TransactionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransactionList& from);
  void MergeFrom(const TransactionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransactionList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_transaction_2eproto);
    return ::descriptor_table_transaction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Transaction transactions = 1;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 1;
  ::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Transaction >*
      mutable_transactions();
  const ::Transaction& transactions(int index) const;
  ::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:TransactionList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Transaction > transactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transaction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransactionHeader

// string batcher_public_key = 1;
inline void TransactionHeader::clear_batcher_public_key() {
  batcher_public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::batcher_public_key() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.batcher_public_key)
  return batcher_public_key_.GetNoArena();
}
inline void TransactionHeader::set_batcher_public_key(const std::string& value) {
  
  batcher_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.batcher_public_key)
}
inline void TransactionHeader::set_batcher_public_key(std::string&& value) {
  
  batcher_public_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.batcher_public_key)
}
inline void TransactionHeader::set_batcher_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  batcher_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.batcher_public_key)
}
inline void TransactionHeader::set_batcher_public_key(const char* value, size_t size) {
  
  batcher_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.batcher_public_key)
}
inline std::string* TransactionHeader::mutable_batcher_public_key() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.batcher_public_key)
  return batcher_public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_batcher_public_key() {
  // @@protoc_insertion_point(field_release:TransactionHeader.batcher_public_key)
  
  return batcher_public_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_batcher_public_key(std::string* batcher_public_key) {
  if (batcher_public_key != nullptr) {
    
  } else {
    
  }
  batcher_public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), batcher_public_key);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.batcher_public_key)
}

// repeated string dependencies = 2;
inline int TransactionHeader::dependencies_size() const {
  return dependencies_.size();
}
inline void TransactionHeader::clear_dependencies() {
  dependencies_.Clear();
}
inline const std::string& TransactionHeader::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:TransactionHeader.dependencies)
  return dependencies_.Get(index);
}
inline std::string* TransactionHeader::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionHeader.dependencies)
  return dependencies_.Mutable(index);
}
inline void TransactionHeader::set_dependencies(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.dependencies)
  dependencies_.Mutable(index)->assign(value);
}
inline void TransactionHeader::set_dependencies(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.dependencies)
  dependencies_.Mutable(index)->assign(std::move(value));
}
inline void TransactionHeader::set_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TransactionHeader.dependencies)
}
inline void TransactionHeader::set_dependencies(int index, const char* value, size_t size) {
  dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.dependencies)
}
inline std::string* TransactionHeader::add_dependencies() {
  // @@protoc_insertion_point(field_add_mutable:TransactionHeader.dependencies)
  return dependencies_.Add();
}
inline void TransactionHeader::add_dependencies(const std::string& value) {
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TransactionHeader.dependencies)
}
inline void TransactionHeader::add_dependencies(std::string&& value) {
  dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TransactionHeader.dependencies)
}
inline void TransactionHeader::add_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TransactionHeader.dependencies)
}
inline void TransactionHeader::add_dependencies(const char* value, size_t size) {
  dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TransactionHeader.dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionHeader::dependencies() const {
  // @@protoc_insertion_point(field_list:TransactionHeader.dependencies)
  return dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionHeader::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:TransactionHeader.dependencies)
  return &dependencies_;
}

// string family_name = 3;
inline void TransactionHeader::clear_family_name() {
  family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::family_name() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.family_name)
  return family_name_.GetNoArena();
}
inline void TransactionHeader::set_family_name(const std::string& value) {
  
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.family_name)
}
inline void TransactionHeader::set_family_name(std::string&& value) {
  
  family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.family_name)
}
inline void TransactionHeader::set_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.family_name)
}
inline void TransactionHeader::set_family_name(const char* value, size_t size) {
  
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.family_name)
}
inline std::string* TransactionHeader::mutable_family_name() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.family_name)
  return family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_family_name() {
  // @@protoc_insertion_point(field_release:TransactionHeader.family_name)
  
  return family_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    
  } else {
    
  }
  family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_name);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.family_name)
}

// string family_version = 4;
inline void TransactionHeader::clear_family_version() {
  family_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::family_version() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.family_version)
  return family_version_.GetNoArena();
}
inline void TransactionHeader::set_family_version(const std::string& value) {
  
  family_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.family_version)
}
inline void TransactionHeader::set_family_version(std::string&& value) {
  
  family_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.family_version)
}
inline void TransactionHeader::set_family_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  family_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.family_version)
}
inline void TransactionHeader::set_family_version(const char* value, size_t size) {
  
  family_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.family_version)
}
inline std::string* TransactionHeader::mutable_family_version() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.family_version)
  return family_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_family_version() {
  // @@protoc_insertion_point(field_release:TransactionHeader.family_version)
  
  return family_version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_family_version(std::string* family_version) {
  if (family_version != nullptr) {
    
  } else {
    
  }
  family_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_version);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.family_version)
}

// repeated string inputs = 5;
inline int TransactionHeader::inputs_size() const {
  return inputs_.size();
}
inline void TransactionHeader::clear_inputs() {
  inputs_.Clear();
}
inline const std::string& TransactionHeader::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TransactionHeader.inputs)
  return inputs_.Get(index);
}
inline std::string* TransactionHeader::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionHeader.inputs)
  return inputs_.Mutable(index);
}
inline void TransactionHeader::set_inputs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.inputs)
  inputs_.Mutable(index)->assign(value);
}
inline void TransactionHeader::set_inputs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.inputs)
  inputs_.Mutable(index)->assign(std::move(value));
}
inline void TransactionHeader::set_inputs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  inputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TransactionHeader.inputs)
}
inline void TransactionHeader::set_inputs(int index, const char* value, size_t size) {
  inputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.inputs)
}
inline std::string* TransactionHeader::add_inputs() {
  // @@protoc_insertion_point(field_add_mutable:TransactionHeader.inputs)
  return inputs_.Add();
}
inline void TransactionHeader::add_inputs(const std::string& value) {
  inputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TransactionHeader.inputs)
}
inline void TransactionHeader::add_inputs(std::string&& value) {
  inputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TransactionHeader.inputs)
}
inline void TransactionHeader::add_inputs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  inputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TransactionHeader.inputs)
}
inline void TransactionHeader::add_inputs(const char* value, size_t size) {
  inputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TransactionHeader.inputs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionHeader::inputs() const {
  // @@protoc_insertion_point(field_list:TransactionHeader.inputs)
  return inputs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionHeader::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TransactionHeader.inputs)
  return &inputs_;
}

// string nonce = 6;
inline void TransactionHeader::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::nonce() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.nonce)
  return nonce_.GetNoArena();
}
inline void TransactionHeader::set_nonce(const std::string& value) {
  
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.nonce)
}
inline void TransactionHeader::set_nonce(std::string&& value) {
  
  nonce_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.nonce)
}
inline void TransactionHeader::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.nonce)
}
inline void TransactionHeader::set_nonce(const char* value, size_t size) {
  
  nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.nonce)
}
inline std::string* TransactionHeader::mutable_nonce() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.nonce)
  return nonce_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_nonce() {
  // @@protoc_insertion_point(field_release:TransactionHeader.nonce)
  
  return nonce_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  nonce_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.nonce)
}

// repeated string outputs = 7;
inline int TransactionHeader::outputs_size() const {
  return outputs_.size();
}
inline void TransactionHeader::clear_outputs() {
  outputs_.Clear();
}
inline const std::string& TransactionHeader::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TransactionHeader.outputs)
  return outputs_.Get(index);
}
inline std::string* TransactionHeader::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionHeader.outputs)
  return outputs_.Mutable(index);
}
inline void TransactionHeader::set_outputs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.outputs)
  outputs_.Mutable(index)->assign(value);
}
inline void TransactionHeader::set_outputs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:TransactionHeader.outputs)
  outputs_.Mutable(index)->assign(std::move(value));
}
inline void TransactionHeader::set_outputs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TransactionHeader.outputs)
}
inline void TransactionHeader::set_outputs(int index, const char* value, size_t size) {
  outputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.outputs)
}
inline std::string* TransactionHeader::add_outputs() {
  // @@protoc_insertion_point(field_add_mutable:TransactionHeader.outputs)
  return outputs_.Add();
}
inline void TransactionHeader::add_outputs(const std::string& value) {
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TransactionHeader.outputs)
}
inline void TransactionHeader::add_outputs(std::string&& value) {
  outputs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TransactionHeader.outputs)
}
inline void TransactionHeader::add_outputs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outputs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TransactionHeader.outputs)
}
inline void TransactionHeader::add_outputs(const char* value, size_t size) {
  outputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TransactionHeader.outputs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionHeader::outputs() const {
  // @@protoc_insertion_point(field_list:TransactionHeader.outputs)
  return outputs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionHeader::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TransactionHeader.outputs)
  return &outputs_;
}

// string payload_sha512 = 9;
inline void TransactionHeader::clear_payload_sha512() {
  payload_sha512_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::payload_sha512() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.payload_sha512)
  return payload_sha512_.GetNoArena();
}
inline void TransactionHeader::set_payload_sha512(const std::string& value) {
  
  payload_sha512_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.payload_sha512)
}
inline void TransactionHeader::set_payload_sha512(std::string&& value) {
  
  payload_sha512_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.payload_sha512)
}
inline void TransactionHeader::set_payload_sha512(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_sha512_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.payload_sha512)
}
inline void TransactionHeader::set_payload_sha512(const char* value, size_t size) {
  
  payload_sha512_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.payload_sha512)
}
inline std::string* TransactionHeader::mutable_payload_sha512() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.payload_sha512)
  return payload_sha512_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_payload_sha512() {
  // @@protoc_insertion_point(field_release:TransactionHeader.payload_sha512)
  
  return payload_sha512_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_payload_sha512(std::string* payload_sha512) {
  if (payload_sha512 != nullptr) {
    
  } else {
    
  }
  payload_sha512_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload_sha512);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.payload_sha512)
}

// string signer_public_key = 10;
inline void TransactionHeader::clear_signer_public_key() {
  signer_public_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransactionHeader::signer_public_key() const {
  // @@protoc_insertion_point(field_get:TransactionHeader.signer_public_key)
  return signer_public_key_.GetNoArena();
}
inline void TransactionHeader::set_signer_public_key(const std::string& value) {
  
  signer_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TransactionHeader.signer_public_key)
}
inline void TransactionHeader::set_signer_public_key(std::string&& value) {
  
  signer_public_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TransactionHeader.signer_public_key)
}
inline void TransactionHeader::set_signer_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signer_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TransactionHeader.signer_public_key)
}
inline void TransactionHeader::set_signer_public_key(const char* value, size_t size) {
  
  signer_public_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TransactionHeader.signer_public_key)
}
inline std::string* TransactionHeader::mutable_signer_public_key() {
  
  // @@protoc_insertion_point(field_mutable:TransactionHeader.signer_public_key)
  return signer_public_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransactionHeader::release_signer_public_key() {
  // @@protoc_insertion_point(field_release:TransactionHeader.signer_public_key)
  
  return signer_public_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionHeader::set_allocated_signer_public_key(std::string* signer_public_key) {
  if (signer_public_key != nullptr) {
    
  } else {
    
  }
  signer_public_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signer_public_key);
  // @@protoc_insertion_point(field_set_allocated:TransactionHeader.signer_public_key)
}

// -------------------------------------------------------------------

// Transaction

// bytes header = 1;
inline void Transaction::clear_header() {
  header_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Transaction::header() const {
  // @@protoc_insertion_point(field_get:Transaction.header)
  return header_.GetNoArena();
}
inline void Transaction::set_header(const std::string& value) {
  
  header_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Transaction.header)
}
inline void Transaction::set_header(std::string&& value) {
  
  header_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Transaction.header)
}
inline void Transaction::set_header(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  header_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Transaction.header)
}
inline void Transaction::set_header(const void* value, size_t size) {
  
  header_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Transaction.header)
}
inline std::string* Transaction::mutable_header() {
  
  // @@protoc_insertion_point(field_mutable:Transaction.header)
  return header_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Transaction::release_header() {
  // @@protoc_insertion_point(field_release:Transaction.header)
  
  return header_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    
  } else {
    
  }
  header_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header);
  // @@protoc_insertion_point(field_set_allocated:Transaction.header)
}

// string header_signature = 2;
inline void Transaction::clear_header_signature() {
  header_signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Transaction::header_signature() const {
  // @@protoc_insertion_point(field_get:Transaction.header_signature)
  return header_signature_.GetNoArena();
}
inline void Transaction::set_header_signature(const std::string& value) {
  
  header_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Transaction.header_signature)
}
inline void Transaction::set_header_signature(std::string&& value) {
  
  header_signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Transaction.header_signature)
}
inline void Transaction::set_header_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  header_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Transaction.header_signature)
}
inline void Transaction::set_header_signature(const char* value, size_t size) {
  
  header_signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Transaction.header_signature)
}
inline std::string* Transaction::mutable_header_signature() {
  
  // @@protoc_insertion_point(field_mutable:Transaction.header_signature)
  return header_signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Transaction::release_header_signature() {
  // @@protoc_insertion_point(field_release:Transaction.header_signature)
  
  return header_signature_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_header_signature(std::string* header_signature) {
  if (header_signature != nullptr) {
    
  } else {
    
  }
  header_signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header_signature);
  // @@protoc_insertion_point(field_set_allocated:Transaction.header_signature)
}

// bytes payload = 3;
inline void Transaction::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Transaction::payload() const {
  // @@protoc_insertion_point(field_get:Transaction.payload)
  return payload_.GetNoArena();
}
inline void Transaction::set_payload(const std::string& value) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Transaction.payload)
}
inline void Transaction::set_payload(std::string&& value) {
  
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Transaction.payload)
}
inline void Transaction::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Transaction.payload)
}
inline void Transaction::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Transaction.payload)
}
inline std::string* Transaction::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:Transaction.payload)
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Transaction::release_payload() {
  // @@protoc_insertion_point(field_release:Transaction.payload)
  
  return payload_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:Transaction.payload)
}

// -------------------------------------------------------------------

// TransactionList

// repeated .Transaction transactions = 1;
inline int TransactionList::transactions_size() const {
  return transactions_.size();
}
inline void TransactionList::clear_transactions() {
  transactions_.Clear();
}
inline ::Transaction* TransactionList::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionList.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Transaction >*
TransactionList::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:TransactionList.transactions)
  return &transactions_;
}
inline const ::Transaction& TransactionList::transactions(int index) const {
  // @@protoc_insertion_point(field_get:TransactionList.transactions)
  return transactions_.Get(index);
}
inline ::Transaction* TransactionList::add_transactions() {
  // @@protoc_insertion_point(field_add:TransactionList.transactions)
  return transactions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Transaction >&
TransactionList::transactions() const {
  // @@protoc_insertion_point(field_list:TransactionList.transactions)
  return transactions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto
